---
title: Apollo iOS 2.0 Migration Guide
---

## Introduction

Apollo iOS 2.0 represents a major evolution of the library, redesigned from the ground up to take full advantage of Swift's modern concurrency model. This release introduces significant breaking changes that require careful migration planning, but provides substantial improvements in type safety, performance, and developer experience.

### What's new in 2.0

Apollo iOS 2.0 brings several foundational changes:

- **Swift Concurrency First**: Complete reimplementation using `async/await` and structured concurrency
- **Streamlined APIs**: Simplified client APIs with clearer separation of concerns and more precise type safety
- **Modern Swift Features**: Full adoption of Swift 6 with strict concurrency enabled

### Breaking changes overview

This migration involves significant API changes across several areas:

1. **ApolloClient API**: Complete redesign using `async/await` instead of callback-based APIs
2. **Cache Policies**: Split into discrete types with specific return signatures
3. **Request Interceptors**: New framework with separate interceptor types for different request phases
4. **Sendable Types**: Most types now conform to `Sendable` with associated constraints

### Limitations

**Minimum Deployment Targets**

Apollo iOS 2.0 drops support for older deployment targets. The minimum deployment targets are now:

- iOS 15.0+
- macOS 12.0+
- tvOS 15.0+
- watchOS 8.0+
- visionOS 1.0+

**CocoaPods Support Removed**

Cocoapods support is no longer available in Apollo iOS 2.0. The library is available via Swift Package Manager or as .xcframeworks built using the [Apollo iOS XCFramework Repo](https://github.com/apollographql/apollo-ios-xcframework).

Code generation of Cocoapods modules is no longer supported.

**Web socket support (Coming Soon)**

The initial release of 2.0 will not support web sockets. Subscriptions over HTTP are supported by `RequestChainNetworkTransport`.

A new implementation of the `ApolloWebSocket` target will be published in a future version as soon as possible. If your application requires web sockets, you should not upgrade to 2.0 until the new web socket implementation is released.

### Migration strategy

Apollo iOS 2.0 migration follows a two-phase approach designed to minimize disruption while ensuring all functionality is properly updated.

**Phase 1: Breaking changes**

Some APIs have fundamentally changed to support the new structured concurrency model and cannot maintain backward compatibility. You must update these implementations before proceeding with the rest of your migration.

These changes include:

- Various changes to request/response models
- `RequestChain` configuration via custom `Interceptors`
- Custom `NetworkTransport` implementations
- Custom `NormalizedCache` implementations

**Phase 2: Incrementally update `ApolloClient` API usage**

The most commonly used APIs for fetching data via `ApolloClient` have been deprecated instead of removed completely. Once the breaking changes have been resolved, this allows you to:

- **Compile and run** your application with the deprecated APIs while planning your migration
- **Update incrementally** - migrate one query, mutation, or subscription at a time
- **Verify behavior** at each step to ensure correctness before proceeding
- **Deploy intermediate states** if needed during a gradual rollout

While we recommend that you update these deprecated APIs to the new versions ASAP, you can do so incrementally while still compiling your application and verifying behavior. You should update these APIs as soon as possible to take advantage of the use of `async/await` and increased type safety of the return types for these APIs.

The remainder of this guide provides detailed instructions for migrating each aspect of your Apollo iOS integration.

## `URLSessionClient` -> `ApolloURLSession`

In Apollo iOS 1.0 a `URLSessionClient` that managed an internal `URLSession` was used to handle network operations. In 2.0, this is replaced by the [`ApolloURLSession`](https://www.apollographql.com/docs/ios/docc/documentation/apollo/apollourlsession) protocol. `URLSession` conforms to this procotol by default. This allows you to provide your own `URLSession` to the `RequestChainNetworkTransport`. You can configure this `URLSession` as needed and provide your own delegates to it.

```swift
let urlSession = URLSession.shared // Conforms to ApolloURLSession
urlSession.delegate = self
let networkTransport = RequestChainNetworkTransport(
  interceptorProvider: DefaultInterceptorProvider.shared,
  endpointURL: url,
  urlSession: urlSession
)
```

## `RequestContext` -> Task Local Values

In Apollo iOS 1.x, you could provide an arbitrary `RequestContext` when initiating a GraphQL operation. This could be accessed by custom interceptors or `NetworkTransport` implementations.

2.0 deprecates `RequestContext` in favor of using Swift 6's `@TaskLocal` values. For more information on using `@TaskLocal` values with your network configuration, see our [Request Chain `@TaskLocal` values documentation](./../advanced/request-chain#dependency-injection-via-tasklocal-values).

## `RequestChain` configuration

The `RequestChain` and interceptor framework has been completely reimagined. The new version supports `async/await` and provides the ability to interact with the request at each step within the chain more safely with more explicit APIs.

If you are providing your own custom `InterceptorProvider` with your own interceptors, you will need to modify your code to utilize these new APIs.

This migration guide provides an overview of the changes. For detailed documentation on the new request chain, see the [Request Chain Configuration documentation](./advanced/request-chain).

Before migrating your `InterceptorProvider` to 2.0, we recommend you familiarize yourself with these key changes to the Request Chain.

### Discreet Interceptors Types

The singular `ApolloInterceptor` protocol that was used to handle any step of the request chain has been broken up into discrete interceptor types for different portions of request execution. This provides a cleaner, more type-safe API for interacting with the request and response at different stages of the RequestChain.

The four interceptor types are:

- `GraphQLInterceptor`
  - Can inspect and mutate the `GraphQLRequest` and `GraphQLResponse`
- `HTTPInterceptor`
  - Can inspect and mutate the `URLRequest`
  - After network response can inspect the `HTTPURLResponse` (readonly) and mutate the actual raw response `Data` **prior to parsing**
- `CacheInterceptor`
  - Handles read/write of cache data
  - Read currently runs before `GraphQLInterceptors` (not sure if that is the desired behavior, we should discuss)
  - Write runs after parsing
- `ResponseParsingInterceptor`
  - Handles the parsing of the response Data into the `GraphQLResponse`

`NetworkFetchInterceptor` is no longer used, as the network fetch is managed by the `ApolloURLSession`. See the section on `ApolloURLSession` for more information.

### Request Chain Flow

In 1.0, interceptors were called once in sequential order. In 2.0, requests are now sent down the request chain pre-flight and then back up the chain post-flight, allowing each interceptor to interact with both the request and response in a type-safe way.

Requests are now processed by the `RequestChain` using the following flow:

- `GraphQLInterceptors` receive and may mutate `Request`
- Cache read executed via `CacheInterceptor` if necessary (based on cache policy)
- `GraphQLRequest.toURLRequest()` called to obtain `URLRequest`
- `HTTPInterceptors` receive and may mutate `URLRequest`
- `ApolloURLSession` handles networking with `URLRequest`
- `HTTPInterceptors` receive stream of `HTTPResponse` objects for each chunk & may mutate raw chunk `Data` stream
- `ResponseParsingInterceptor` receives `HTTPResponse` and parses data chunks into stream of `GraphQLResponse`
- `GraphQLInterceptors` receive and may mutate `GraphQLResponse` with parsed `GraphQLResult` and (possibly) cache records.
- Cache write executed via `CacheInterceptor` if necessary (based on cache policy)
- `GraphQLResponse` emitted out to `NetworkTransport`

### Error Handling

The `ApolloErrorInterceptor` has been removed from 2.0. Instead, any `GraphQLInterceptor` can intercept errors by calling the `mapErrors` function of the `InterceptorResultStream`. Errors can even be intercepted by multiple interceptors that perform different error handling logic.

For more information on error handling see the [Request Chain error handling documentation](./../advanced/request-chain#error-handling).

### Retrying Requests

In 1.0, you could retry a `RequestChain`'s request by calling `chain.retry(request:completion)`. In Apollo iOS 2.0, interceptors no longer have access to the `RequestChain` itself. Instead, interceptors can trigger a retry by throwing a `RequestChain.Retry` error.

For more information on retrying see the [Request Chain request retries documentation](./../advanced/request-chain#request-retries).

### Converting 1.x interceptor providers

Converting your existing custom `InterceptorProvider` to 2.0 requires two main steps:

1. **Refactor existing interceptors** to use one of the four new discrete interceptor types
2. **Update your `InterceptorProvider`** to conform to the new protocol structure

#### Step 1: Refactor existing interceptors

In 1.x, all custom logic was implemented using the `ApolloInterceptor` protocol. In 2.0, you need to choose the appropriate interceptor type based on what your interceptor does. See the linked documentation for each interceptor type for more information on how to implement them.

- **[`GraphQLInterceptor`](./../advanced/request-chain#graphqlinterceptor):** Provides access to the `GraphQLRequest` and the parsed `GraphQLResponse`. Most interceptors from 1.0 should use this type.
- **[`HTTPInterceptor`](./../advanced/request-chain#httpinterceptor):** Provides access to the `HTTPURLResponse` and the raw data stream of the network response.
- **[`CacheInterceptor`](./../advanced/request-chain#cacheinterceptor):** To implement custom caching logic use a `CacheInterceptor`.
- **[`ResponseParsingInterceptor`](./../advanced/request-chain#responseparsinginterceptor):** Parses raw response data into a `GraphQLResponse` and set of records for writing to the cache.

#### Step 2: Update your InterceptorProvider

1.x InterceptorProvider:
```swift
// 1.x approach
class CustomInterceptorProvider: InterceptorProvider {
  private let store: ApolloStore
  private let client: URLSessionClient

  init(store: ApolloStore, client: URLSessionClient) {
    self.store = store
    self.client = client
  }

  func interceptors<Operation: GraphQLOperation>(for operation: Operation) -> [ApolloInterceptor] {
    return [
      MaxRetryInterceptor(),
      CacheReadInterceptor(store: self.store),
      AuthInterceptor(),
      CustomHeaderInterceptor(),
      LoggingInterceptor(),
      NetworkFetchInterceptor(client: self.client),
      ResponseCodeInterceptor(),
      JSONResponseParsingInterceptor(),
      AutomaticPersistedQueryInterceptor(),
      CacheWriteInterceptor(store: self.store)
    ]
  }
}
```

2.0 InterceptorProvider:
```swift
// 2.0 approach
struct CustomInterceptorProvider: InterceptorProvider {
  private let store: ApolloStore

  init(store: ApolloStore) {
    self.store = store
  }

  // Provide GraphQL interceptors (pre/post-flight GraphQL processing)
  func graphQLInterceptors<Operation: GraphQLOperation>(for operation: Operation) -> [any GraphQLInterceptor] {
    return [
      MaxRetryInterceptor(),
      AuthInterceptor(token: getCurrentToken()),
      LoggingInterceptor(),
      AutomaticPersistedQueryInterceptor()
    ]
  }

  // Provide cache interceptor (cache read/write operations)
  func cacheInterceptor<Operation: GraphQLOperation>(for operation: Operation) -> any CacheInterceptor {
    return CustomCacheInterceptor()
  }

  // Provide HTTP interceptors (URLRequest/HTTPResponse processing)
  func httpInterceptors<Operation: GraphQLOperation>(for operation: Operation) -> [any HTTPInterceptor] {
    return [
      CustomHeaderInterceptor(),
      ResponseCodeInterceptor()
    ]
  }

  // Provide response parser (HTTP data â†’ GraphQL response)
  func responseParser<Operation: GraphQLOperation>(for operation: Operation) -> any ResponseParsingInterceptor {
    return JSONResponseParsingInterceptor()
  }
}
```

#### Using your converted InterceptorProvider

Once converted, use your provider with `RequestChainNetworkTransport`:

```swift
let store = ApolloStore(cache: InMemoryNormalizedCache())
let customProvider = CustomInterceptorProvider(store: store)

let networkTransport = RequestChainNetworkTransport(
  interceptorProvider: customProvider,
  endpointURL: URL(string: "https://api.example.com/graphql")!,
  urlSession: URLSession.shared
)

let apolloClient = ApolloClient(networkTransport: networkTransport, store: store)
```

#### Migration checklist

When converting your interceptor provider:

- [ ] **Categorize each interceptor** by its primary function
- [ ] **Convert to appropriate type**: GraphQL, HTTP, Cache, or ResponseParsing
- [ ] **Update async patterns**: Replace callbacks with `async/await` and streams
- [ ] **Handle errors properly**: Use `.mapErrors()` instead of completion handlers
- [ ] **Test thoroughly**: Verify that request/response flow works as expected
- [ ] **Remove `NetworkFetchInterceptor`**: This is now handled by `ApolloURLSession`

For detailed information on implementing custom interceptors, see the [Request Chain Customization documentation](./advanced/request-chain).

**2.0 GraphQLInterceptor:**
```swift
// 2.0 approach
struct MyInterceptor: GraphQLInterceptor {
  func intercept<Request: GraphQLRequest>(
    request: Request,
    next: @escaping NextGraphQLInterceptorFunction<Request>
  ) -> InterceptorResultStream<Request> {

    // Pre-flight: modify request
    let modifiedRequest = modifyRequest(request)

    // Post-flight: modify response using stream operations
    return next(modifiedRequest)
      .map { result in
        return modifyResult(result)
      }
      .mapErrors { error in
        // Handle errors
        throw error
      }
  }
}
```

For detailed migration guidance, see the [Apollo iOS 2.0 migration guide](./../migrations/2.0).